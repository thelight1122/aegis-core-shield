// src/main/ids.ts
// Purpose: IDS core skeleton – Identify → Define → Suggest
// Only admitted prompts from Discernment Gate reach here
// v0.1: placeholders for each phase – no deep logic yet
// Append-only – add phase implementations later, never replace

import { discernmentGate } from './src/shared/main/discernment-gate';

export interface IDSResult {
    identified: any;
    defined: any;
    suggested: any;
}

/**
 * Main IDS flow – only called on admitted prompts
 */
export function runIDS(admittedPrompt: string): IDSResult {
    // Phase 1: Identify
    const identified = identify(admittedPrompt);

    // Phase 2: Define
    const defined = define(identified);

    // Phase 3: Suggest
    const suggested = suggest(defined);

    return {
        identified,
        defined,
        suggested,
    };
}

// Phase 1: Identify – observe basic patterns (entities, intent, force markers)
function identify(prompt: string): any {
    const words = prompt.toLowerCase().split(/\s+/);

    // Simple entity/intent observation
    const entities = words.filter(w => w.length > 3 && !['the', 'and', 'for', 'with'].includes(w));
    const hasImperative = words.some(w => ['must', 'should', 'need', 'have to'].includes(w));
    const hasQuestion = prompt.includes('?');

    return {
        rawPrompt: prompt,
        wordCount: words.length,
        observedEntities: entities.slice(0, 5), // top 5 for brevity
        intentSignals: {
            imperative: hasImperative,
            question: hasQuestion,
            neutral: !hasImperative && !hasQuestion
        },
        forceMarkersDetected: hasImperative ? ['imperative detected'] : []
    };
}

// Phase 2: Define – name patterns, map context (minimal)
function define(identified: any): any {
    const intentSignals = identified?.intentSignals || {};
    const imperative = !!intentSignals.imperative;
    const question = !!intentSignals.question;

    let patternName = 'Descriptive / Open Intent';
    if (imperative && question) {
        patternName = 'Directive Inquiry';
    } else if (imperative) {
        patternName = 'Directive Intent';
    } else if (question) {
        patternName = 'Inquiry Intent';
    }

    const entities = Array.isArray(identified?.observedEntities) ? identified.observedEntities : [];
    const forceMarkers = Array.isArray(identified?.forceMarkersDetected) ? identified.forceMarkersDetected : [];
    const wordCount = typeof identified?.wordCount === 'number' ? identified.wordCount : 0;
    const hasForce = forceMarkers.length > 0;

    const contextMap = {
        intent: imperative ? 'imperative' : question ? 'question' : 'neutral',
        length: wordCount,
        entities,
        entityCount: entities.length,
        forceMarkers,
        hasForce
    };

    const entityList = entities.length ? entities.join(', ') : 'none';
    const contextSummary = `Prompt length: ${wordCount} words. Entities observed: ${entityList}.` +
        (hasForce ? ' Force markers present.' : '');

    return {
        ...identified,
        patternName,
        contextMap,
        contextSummary
    };
}

// Phase 3: Suggest – coherent next steps (non-force, placeholder)
function suggest(defined: any): any {
    const patternName = String(defined.patternName || '');
    const isDirective = patternName.includes('Directive');

    const suggestion = isDirective
        ? 'Consider rephrasing as observation or question to increase resonance.'
        : 'Prompt aligns with open inquiry. Ready for deeper exploration.';

    return {
        ...defined,
        suggestion,
        nextStepOptions: [
            'Refine intent',
            'Ask clarifying question',
            'Proceed with current framing'
        ]
    };
}
// Integration with gate (example usage)
export function processPrompt(rawPrompt: string): any {
    const gateResult = discernmentGate(rawPrompt);

    if (gateResult.admitted) {
        const idsResult = runIDS(gateResult.payload as string);
        // Return to user (CLI print, GUI display, API response)
        return idsResult;
    } else {
        // Return packet already generated by gate
        return gateResult.payload;
    }
}